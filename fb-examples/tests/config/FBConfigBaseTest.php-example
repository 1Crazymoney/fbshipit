<?hh // strict
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
namespace Facebook\ShipIt\Config;

use \Facebook\ShipIt\ {
  FBPublicProjectBaseTest,
  ShipItChangeset,
};

use \Facebook\ImportIt\ {
  ImportItSubmoduleFilter,
};

abstract class FBConfigBaseTest extends FBPublicProjectBaseTest {

  <<__Override>>
  final public function testFileNameMatchesRepo(): void {
    $config_class = self::getConfigClass();
    $config = $config_class::getStaticConfig();
    $reflector = new \ReflectionClass($config_class);
    $this->assertEquals(
      $config['githubOrg'],
      basename(dirname($reflector->getFileName())),
      'Config parent directory must match GitHub Org: '.$config_class
    );
    $this->assertEquals(
      $config['githubProject'].'.php',
      basename($reflector->getFileName()),
      'Config filename must match GitHub Repo: '.$config_class
    );
  }

  <<__Override>>
  final protected static function getShipItClass(
  ): classname<\Facebook\ImportIt\ISupportsFBImportIt> {
    return self::getConfigClass();
  }

  final protected static function getConfigClass(
  ): classname<\Facebook\ShipIt\FBShipItConfig> {
    $shipit_class = preg_replace(
      '/([a-zA-Z0-9_]+)Test$/',
      '\1',
      static::class,
    );
    invariant(
      class_exists($shipit_class, true),
      '%s does not exist.  Test and ShipIt class are not named consistently.',
      $shipit_class,
    );
    return $shipit_class;
  }

  /////////////////////////
  //
  // ImportIt config tests
  //
  /////////////////////////

  /**
   * Example input/output paths for filter.
   *
   * Projects can override this, but by default, it uses the inverse of the
   * ShipIt example.
   *
   * @returns a map from source path to either a destination path, or null if
   *   changes to the specified internal path should be removed from the
   *   destination repository.
   */
  protected static function getExampleImportPathMappings(
  ): ImmMap<string, string> {
    $shipit_examples = static::getExamplePathMappings();
    $mapping = Map {};
    foreach ($shipit_examples as $dest_path => $src_path) {
      if ($src_path === null) {
        continue;
      }
      $mapping[$src_path] = $dest_path;
    }
    return $mapping->toImmMap();
  }

  protected static function mapImport(
    \Facebook\ShipIt\ShipItChangeset $changeset,
  ): \Facebook\ShipIt\ShipItChangeset {
    $config_class = static::getConfigClass();
    return $config_class::importChangeset($changeset);
  }

  final public function exampleImportPathMappings(
  ): array<string, (string, ?string)> {
    return static::getExampleImportPathMappings()
      ->mapWithKey(($k, $v) ==> tuple($k, $v))
      ->toArray();
  }

  /**
   * @dataProvider exampleImportPathMappings
   */
  final public function testImportPathMapping(
    string $path_in,
    ?string $path_expected,
  ): void {
    $diffs = ImmVector { shape('path' => $path_in, 'body' => 'junk') };
    $changeset = (new ShipItChangeset())->withDiffs($diffs);
    $this->pathMappingCheck($changeset, $path_in, $path_expected);
  }

  final protected function importPathMappingCheck(
    ShipItChangeset $changeset,
    string $path_in,
    ?string $path_expected,
  ): void {
    $changeset = static::mapImport($changeset);

    if ($path_expected === null) {
      $expected_paths = [];
      $message = sprintf('Expected `%s` to be stripped', $path_in);
    } else {
      $expected_paths = [$path_expected];
      $message = sprintf(
        'Expected `%s` to map to `%s`',
        $path_in,
        $path_expected,
      );
    }
    $this->assertEquals(
      $expected_paths,
      $changeset->getDiffs()->map($diff ==> $diff['path'])->toArray(),
      sprintf(
        "%s.  Debug messages follow:\n%s",
        $message,
        implode("\n", $changeset->getDebugMessages()),
      ),
    );
  }

  final public function testImportBranches(): void {
    $config_class = static::getConfigClass();
    $importit_base_config = $config_class::getImportBaseConfig();
    $shipit_base_config = $config_class::getBaseConfig();
    $this->assertEquals(
      $shipit_base_config->getSourceBranch(),
      $importit_base_config->getDestinationBranch(),
      'Destination branch should be the inverse of the source branch.',
    );
    $this->assertEquals(
      $shipit_base_config->getDestinationBranch(),
      $importit_base_config->getSourceBranch(),
      'Source branch should be the inverse of the destination branch.',
    );
  }

  final public function testImportRepositoryNameCollision(): void {
    $config_class = static::getConfigClass();
    $config = $config_class::getImportBaseConfig();
    $this->assertNotEquals(
      $config->getSourcePath(),
      $config->getDestinationPath(),
      'ShipIt repo names match and `getStaticConfig` has not set '.
        '`destDirName` to something unique for the destination repository!',
    );
  }

  final public function testSubmodulesAreImportedCorrectly(): void {
    $config_class = static::getConfigClass();
    $parents = new Set(class_parents($config_class));
    foreach ($config_class::getSubmoduleMappings() as $rev_file => $dest) {
      $changeset = (new ShipItChangeset())
        ->withDiffs(ImmVector {
          shape(
            'path' => $rev_file,
            'body' => (string) self::invoke_static_bypass_visibility(
              ImportItSubmoduleFilter::class,
              'makeSubmoduleDiff',
              $rev_file,
              'deadbeef1',
              'deadbeef2',
            ),
          ),
        });
      $this->importPathMappingCheck($changeset, $dest, $rev_file);
    }
  }
}
